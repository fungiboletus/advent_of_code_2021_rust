#[derive(Debug)]
pub struct Map {
    // data is an array of arrays of i64s
    // data[x][y] is the value at the x,y coordinate
    data: Vec<Vec<i64>>,
}

impl Default for Map {
    fn default() -> Self {
        Map {
            // Create a vector of 1000 vectors of 1000 i64s 0
            data: vec![vec![0; 1000]; 1000],
        }
    }
}

pub fn parse_map(data: &str, diagonal: bool) -> Map {
    let mut lines = data.lines();

    // Generated by Github Copilot

    let mut map = Map::default();

    while let Some(line) = lines.next() {
        let mut from_to_split = line.split(" -> ");
        let from = from_to_split.next().expect("No line segment");
        let mut from_split = from.split(",");
        let mut x1 = from_split
            .next()
            .expect("No x1")
            .parse::<i64>()
            .expect("Could not parse x1");
        let mut y1 = from_split
            .next()
            .expect("No y1")
            .parse::<i64>()
            .expect("Could not parse y1");
        let to = from_to_split.next().expect("No line segment");
        let mut to_split = to.split(",");
        let mut x2 = to_split
            .next()
            .expect("No x2")
            .parse::<i64>()
            .expect("Could not parse x2");
        let mut y2 = to_split
            .next()
            .expect("no y2")
            .parse::<i64>()
            .expect("Could not parse y2");

        if x1 == x2 {
            if y1 > y2 {
                std::mem::swap(&mut y1, &mut y2);
            }
            for y in y1..=y2 {
                map.data[x1 as usize][y as usize] += 1;
            }
        } else if y1 == y2 {
            if x1 > x2 {
                std::mem::swap(&mut x1, &mut x2);
            }
            for x in x1..=x2 {
                map.data[x as usize][y1 as usize] += 1;
            }
        } else if diagonal {
            let x_unit = if (x2 - x1) > 0 { 1 } else { -1 };
            let y_unit = if (y2 - y1) > 0 { 1 } else { -1 };

            while x1 != x2 || y1 != y2 {
                map.data[x1 as usize][y1 as usize] += 1;
                x1 += x_unit;
                y1 += y_unit;
            }
            map.data[x1 as usize][y1 as usize] += 1;
        }
    }

    return map;
}

fn sum_of_above_1(map: &Map) -> i64 {
    let mut sum = 0;

    for x in 0..1000 {
        for y in 0..1000 {
            if map.data[x][y] > 1 {
                sum += 1;
            }
        }
    }

    return sum;
}

pub fn day_5_part_1(data: &str) -> i64 {
    let map = parse_map(data, false);
    return sum_of_above_1(&map);
}

pub fn day_5_part_2(data: &str) -> i64 {
    let map = parse_map(data, true);
    return sum_of_above_1(&map);
}

#[cfg(test)]
mod tests {
    use super::*;

    const EXAMPLE: &str = "0,9 -> 5,9
8,0 -> 0,8
9,4 -> 3,4
2,2 -> 2,1
7,0 -> 7,4
6,4 -> 2,0
0,9 -> 2,9
3,4 -> 1,4
0,0 -> 8,8
5,5 -> 8,2";

    #[test]
    fn test_day_5_part_1() {
        assert_eq!(day_5_part_1(EXAMPLE), 5);
    }

    #[test]
    fn test_day_5_part_2() {
        assert_eq!(day_5_part_2(EXAMPLE), 12);
    }
}
